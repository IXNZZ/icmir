use std::{fs, io};
use std::collections::HashMap;
use std::fs::File;
use std::io::{BufReader, Read, Seek, SeekFrom};
use std::iter::Map;
use std::path::{Path, PathBuf};
use bytes::{Buf, Bytes, BytesMut};
use flate2::{FlushDecompress, Status};
use moka::sync::{Cache, CacheBuilder};
use tracing::warn;


const IMAGE_DIR: &str = "data";
const MAP_DIR: &str = "map";
const IMAGE_FILE_SUFFIX: &str = "wzl";
const IMAGE_IDX_SUFFIX: &str = "idx";
const IMAGE_WZX_SUFFIX: &str = "wzx";

const MAP_FILE_SUFFIX: &str = "map";


/// 数据KEY格式
/// 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
///     |8位文件类型|8位序号   | 12位文件名称   | 32位数据文件索引
/// 60-63位: 缓存级别
/// 52-59位: 文件类型
///          0: wzl
///          1: wzx
///          2: idx
///          3: map
///          4: wav
/// 44-51位: 8位序号
/// 32-43位: 12位文件名称编号
/// 00-31位: 32位数据文件索引
pub enum FileDesc {
    KEY (u64),
    // KEYS (Vec<u64>),
    ZONE {file: u16, number: u16, index: u32 },
    // ZONES {file: u16, number: u16, index: Vec<u32> },
    ORDER {file: u16, number: u16, index: u32, count: u32 }

}

impl FileDesc {

    pub fn get_file_key(&self) -> u32 {
        self.get_map_key() & 0xFFFFF
    }

    pub fn get_cache_key(&self) -> u64 {
        match self {
            FileDesc::KEY(k) => {*k & ((1 << 52) -1)}
            FileDesc::ZONE { file, number, index } => {
                (self.get_map_key() as u64) << 32 | *index as u64
            }
            FileDesc::ORDER { file, number, index, count } => {
                (self.get_map_key() as u64) << 32 | (*index + *count) as u64
            }
        }
    }

    fn get_map_key(&self) -> u32 {
        match self {
            FileDesc::KEY(k) => { (*k >> 32) as u32 }
            // FileDesc::KEYS(_) => { 0 }
            FileDesc::ZONE { file, number, .. } => { (*number as u32) << 12 | *file as u32 }
            // FileDesc::ZONES { file, number, .. } => { (*number as u32) << 12 | *file as u32 }
            FileDesc::ORDER { file, number, .. } => { (*number as u32) << 12 | *file as u32 }
        }
    }

}

/// 52-59位: 文件类型
///          0: wzl
///          1: wzx
///          2: idx
///          3: map
///          4: wav
#[derive(PartialEq)]
pub enum FileDescType {
    WZL,
    WZX,
    IDX,
    MAP,
    WAV,
}

impl FileDescType {
    fn get_value(&self) -> u64 {
        match self {
            FileDescType::WZL => {0}
            FileDescType::WZX => {1 << 52}
            FileDescType::IDX => {2 << 52}
            FileDescType::MAP => {3 << 52}
            FileDescType::WAV => {4 << 52}
        }
    }
}

#[derive(Clone, Default)]
pub struct ImageData {
    pub width: u16,
    pub height: u16,
    pub offset_x: i16,
    pub offset_y: i16,
    pub bytes: Bytes,
}

impl ImageData {
    pub fn from(src: &[u8]) -> Self {
        Self::from_head_data(&src[..16], &src[16..])
    }

    pub fn from_head_data(head: &[u8], data: &[u8]) -> Self {
        let mut body = head;
        let pixel = body.get_u8();
        let _compress = body.get_u8();
        let _reserve = body.get_u8();
        let _compress_level = body.get_u8();

        let width = body.get_u16_le();
        let height = body.get_u16_le();
        let offset_x = body.get_i16_le();
        let offset_y = body.get_i16_le();
        let length = body.get_u32_le();

        // if length == 0 && data.len() > 0 {
        //     length = data.len() as u32;
        // }

        if length == 0 {
            let bytes = if data.len() > 0 {
                Bytes::from(byte_to_rgba(pixel, width as usize, height as usize, data))
            } else { Bytes::new() };
            Self { width, height, offset_x, offset_y, bytes }
        } else {
            let x = deflate_image(data, width as u32 * height as u32);
            let data = byte_to_rgba(pixel, width as usize, height as usize, &x[..]);
            Self { width, height, offset_x, offset_y, bytes: Bytes::from(data) }
        }
    }
}

pub struct ImageAsset {
    dir: String,
    file_map: HashMap<u32, String>,
    index_map: HashMap<u32, Vec<u32>>,
    wzx_map: HashMap<u32, Vec<u32>>,
    image_cache: Cache<u64, ImageData>
}

impl ImageAsset {

    pub fn new(dir: String) -> Self {

        ImageAsset {
            dir,
            file_map: HashMap::with_capacity(1024),
            index_map: HashMap::with_capacity(1024),
            wzx_map: HashMap::with_capacity(1024),
            image_cache: Cache::new(10_000)
        }
    }

    pub fn put_file_map(&mut self, key: u32, value: &str, preload_index: bool) {
        self.file_map.insert(key, value.to_string());
        if preload_index {
            self.index_map.insert(key, self.load_idx(value, 0, IMAGE_IDX_SUFFIX));
            self.wzx_map.insert(key, self.load_idx(value, 12, IMAGE_WZX_SUFFIX));
        }
    }

    fn load_idx(&self, name: &str, skip: usize, extension: &str) -> Vec<u32> {
        let path = Path::new(self.dir.as_str()).join(IMAGE_DIR).join(name).with_extension(extension);
        if let Ok(p) = fs::read(path) {
            p.chunks(4).skip(skip).map(|x| {
                let t: [u8; 4] = [x[0], x[1], x[2], x[3]];
                u32::from_le_bytes(t)
            }).collect()
        } else {
            Vec::new()
        }

    }

    pub fn load_image(&mut self, desc: FileDesc, typ: FileDescType) -> Option<ImageData> {
        let type_value = typ.get_value();
        let file_key = desc.get_file_key();
        let key = desc.get_cache_key() | type_value;
        if let Some(value) = self.image_cache.get(&key) {
            if value.bytes.len() <= 0 { return None }
            return Some(value);
        }

        let idx_key = file_key | (type_value >> 32) as u32;
        self.load_index_and_image(file_key, idx_key, key, typ);
        if let Some(value) = self.image_cache.get(&key) {
            if value.bytes.len() <= 0 { return None }
            return Some(value);
        }
        self.image_cache.insert(key, ImageData::default());

        None
    }

    fn load_index_and_image(&mut self, file_key: u32, index_key: u32, cache_key: u64, typ: FileDescType) {
        if let Some(file_name) = self.get_file_name(file_key) {
            let map = if typ == FileDescType::IDX { &self.index_map} else { &self.wzx_map };
            let suffix = if typ == FileDescType::IDX { IMAGE_IDX_SUFFIX} else { IMAGE_WZX_SUFFIX };
            if !map.contains_key(&index_key) {
                let file_idx_value = self.load_idx(file_name.as_str(), 0, suffix);
                if typ == FileDescType::IDX {
                    self.index_map.insert(index_key, file_idx_value);
                } else {
                    self.wzx_map.insert(index_key, file_idx_value);
                }
            }
            let map = if typ == FileDescType::IDX { &self.index_map} else { &self.wzx_map };
                let image_key = if let Some(ik) = map.get(&index_key) {
                    if let Some(v) = ik.get((cache_key & 0xFFFFFFFF) as usize) {
                        if let Some(len) = ik.get(((cache_key + 1) & 0xFFFFFFFF) as usize) {
                            Some((*v, *len - *v))
                        } else {
                            Some((*v, 16))
                        }
                    } else { None }
                } else { None };

                self.get_bytes_by_image_key(image_key, file_name.as_str(), cache_key);
        }
    }

    fn get_bytes_by_image_key(&mut self, image_key: Option<(u32, u32)>, file_name: &str, key: u64) {
        if let Some(v) = image_key {
            if let Some(x) = self.get_file_bytes(file_name, v.0, v.1) {
                println!("idx: {}, {}", v.0, v.1);
                println!("name: {}, key: {}, w: {}, h: {}, x: {}, y: {}", file_name, key, x.width, x.height, x.offset_x, x.offset_y);
                self.image_cache.insert(key, x);
            }
        }
    }

    fn get_file_bytes(&self, file_name: &str, seek: u32, length: u32) -> Option<ImageData> {
        if seek == 0 { return None }
        let path = Path::new(self.dir.as_str()).join(IMAGE_DIR).join(file_name).with_extension(IMAGE_FILE_SUFFIX);
        // println!("file: {}, seek:{}", file_name, seek);
        if let Ok(f) = File::open(path) {
            let mut buf = BufReader::new(f);
            return read_image_data(&mut buf, seek, length);
        }
        None
    }

    fn get_file_name(&mut self, file_key: u32) -> Option<String> {
        if let Some(v) = self.file_map.get(&file_key) {
             return Some(v.to_string());
        }

        let file_key1 = file_key & 0xFFF;
        if let Some(v) = self.file_map.get(&file_key1) {
            let v = format!("{}{}", v, file_key >> 12);
            self.file_map.insert(file_key, v.clone());
            return Some(v);
        }

        None
    }

}

pub fn create_map(base_dir: &str, name: &str) -> Option<MapInfo> {
    // println!("read_map_file: {}", path);
    let path = Path::new(base_dir).join(MAP_DIR).join(name).with_extension(MAP_FILE_SUFFIX);
    println!("path: {:?}", path);
    if let Ok(file) = fs::read(path) {
        let mut buf = &file[..52];
        let width = buf.get_u16_le() as u32;
        let height = buf.get_u16_le() as u32;

        let mut buf = &file[52..];
        let file_size = buf.len();
        let step = ((file_size as u32) / (width * height));
        let tiles: Vec<Tile> = buf.chunks(step as usize).map(|x| {
            Tile::from(x)
        }).collect();
        return Some(MapInfo {width, height, name: name.to_string(), tiles})
    }
    None
    // let name = path.file_name().unwrap().to_str().unwrap().to_string();
    // let file_size = path.metadata().unwrap().len();
    // let mut file = File::open(path).unwrap();
    // let mut header = [0u8; 52];
    // file.read(&mut header).unwrap();
    // let mut header = &header[..];
    // let width = header.get_u16_le() as u32;
    // let height = header.get_u16_le() as u32;
    // let length = ((file_size as u32 - 52) / (width * height)) as usize;
    // let mut body = Vec::with_capacity(file_size as usize -52);
    // file.read_to_end(&mut body).unwrap();
    // // let mut reader = BufReader::new(file);
    // let mut tiles = Vec::with_capacity((width * height) as usize);
    // for i in 0..width * height {
    //     let start = i as usize * length;
    //     let end = start + length;
    //     let tile = Tile::from(&body[start..end]);
    //     tiles.push(tile);
    // }

}

pub struct MapInfo {
    pub width: u32,
    pub height: u32,
    pub name: String,
    pub tiles: Vec<Tile>
}

#[derive(Debug, Clone)]
pub struct Tile {
    pub back: u16,
    pub middle: u16,
    pub objects: u16,
    pub door_idx: u8,
    pub door_offset: u8,
    pub frame: u8,
    pub tick: u8,
    pub file_idx: u8,
    pub light: u8,
    pub tile_idx: u8,
    pub middle_idx: u8,
}

impl Tile {
    pub fn from(bytes: &[u8]) -> Self {
        let len = bytes.len();
        let mut bytes = bytes;
        let back = bytes.get_u16_le();
        let middle = bytes.get_u16_le();
        let objects = bytes.get_u16_le();
        let door_idx = bytes.get_u8();
        let door_offset = bytes.get_u8();
        let frame = bytes.get_u8();
        let tick = bytes.get_u8();
        let file_idx = bytes.get_u8();
        let light = bytes.get_u8();
        let tile_idx = if len > 12 { bytes.get_u8() } else { 0 };
        let middle_idx = if len > 13 { bytes.get_u8() } else { 0 };

        Tile { back, middle, objects, door_idx, door_offset, frame, tick, file_idx, light, tile_idx, middle_idx }
    }
}


pub fn create_default_image_asset(dir: &str) -> ImageAsset {
    let mut asset = ImageAsset::new(dir.to_string());
    asset.put_file_map(1, "tiles", true);
    asset.put_file_map(2, "smTiles", true);
    asset.put_file_map(3, "objects", true);

    asset
}

fn read_image_data(reader: &mut BufReader<File>, seek: u32, length: u32) -> Option<ImageData> {
    if reader.seek(SeekFrom::Start(seek as u64)).is_err() {
        return None;
    }

    let mut data = vec![0;length as usize];
    reader.seek(SeekFrom::Start(seek as u64)).unwrap();
    read_buffer(reader, &mut data[..]);
    println!("{:X?}", data.as_slice());
    if length <= 16 {
        let mut x = &data[12..];
        let x = x.get_u32_le();
        if x > 0 {
            let mut i = vec![0; x as usize];
            read_buffer(reader, &mut i[..]);
            return Some(ImageData::from_head_data(&data[..], &i[..]))
        }
    }
    Some(ImageData::from(&data[..]))
}

fn read_buffer(reader: &mut BufReader<File>, buffer: &mut [u8]) {
    let length = buffer.len();
    let len = reader.read(buffer).unwrap();
    if len < length {
        reader.read(&mut buffer[len..]).unwrap();
    }
}

fn deflate_image(input: &[u8], size: u32) -> Vec<u8> {
    let capacity = size * 4;
    let mut rs: Vec<u8> = Vec::with_capacity(capacity as usize);
    let status = flate2::Decompress::new(true).decompress_vec(input, &mut rs, FlushDecompress::Finish).unwrap();
    if status != Status::StreamEnd {
        warn!("input: {}, output: {}, status: {:?}, size: {}, size*2: {}", input.len(), rs.len(), status, size, size *2);
        // return deflate_image(input, size * 2);
    }
    rs
}

fn byte_to_rgba(pixel: u8, width: usize, height: usize, bytes: &[u8]) -> Vec<u8> {

    if pixel == 3 {
        let mut result = Vec::with_capacity(bytes.len() * 4);
        let new_width = bytes.len() / height;
        let n_width = (width + 3) / 4 * 4;
        let n_width = if n_width > new_width { new_width } else { n_width };
        let n_width = if new_width > n_width { width } else { n_width };
        for i in 0..height {
            for j in 0..width {
                let x = bytes[(height - i - 1) * n_width + j] as usize * 4;
                result.extend_from_slice(&PALETTE_RGBA[x..x+4]);
            }
        }
        return result;
    } else {
        let mut result = Vec::with_capacity(bytes.len() * 2);
        let new_width = bytes.len() / height / 2;
        let n_width = (width + 3) / 4 * 4;
        let n_width = if n_width > new_width { new_width } else { n_width };
        let n_width = if new_width > n_width { width } else { n_width };
        for i in 0..height {
            for j in 0..width {
                let p = (height - i - 1) * n_width * 2 + j * 2;
                result.push(bytes[p + 1] & 0xF8);
                result.push((((bytes[p + 1] & 0x7) << 3) | (bytes[p] >> 5)) * 4);
                result.push((bytes[p] & 0x1F) * 8);
                result.push(if bytes[p] == 0 && bytes[p + 1] == 0 { 0 } else { 255 });
            }
        }
        return result;
    }
}

const PALETTE_RGBA: [u8; 1024] = [
    0x00,0x00,0x00,0x00,0x80,0x00,0x00,0xFF,0x00,0x80,0x00,0xFF,0x80,0x80,0x00,0xFF,0x00,0x00,0x80,0xFF,0x80,0x00,0x80,0xFF,0x00,0x80,0x80,0xFF,0xC0,0xC0,0xC0,0xFF,
    0x55,0x80,0x97,0xFF,0x9D,0xB9,0xC8,0xFF,0x7B,0x73,0x73,0xFF,0x2D,0x29,0x29,0xFF,0x5A,0x52,0x52,0xFF,0x63,0x5A,0x5A,0xFF,0x42,0x39,0x39,0xFF,0x1D,0x18,0x18,0xFF,
    0x18,0x10,0x10,0xFF,0x29,0x18,0x18,0xFF,0x10,0x08,0x08,0xFF,0xF2,0x79,0x71,0xFF,0xE1,0x67,0x5F,0xFF,0xFF,0x5A,0x5A,0xFF,0xFF,0x31,0x31,0xFF,0xD6,0x5A,0x52,0xFF,
    0x94,0x10,0x00,0xFF,0x94,0x29,0x18,0xFF,0x39,0x08,0x00,0xFF,0x73,0x10,0x00,0xFF,0xB5,0x18,0x00,0xFF,0xBD,0x63,0x52,0xFF,0x42,0x18,0x10,0xFF,0xFF,0xAA,0x99,0xFF,
    0x5A,0x10,0x00,0xFF,0x73,0x39,0x29,0xFF,0xA5,0x4A,0x31,0xFF,0x94,0x7B,0x73,0xFF,0xBD,0x52,0x31,0xFF,0x52,0x21,0x10,0xFF,0x7B,0x31,0x18,0xFF,0x2D,0x18,0x10,0xFF,
    0x8C,0x4A,0x31,0xFF,0x94,0x29,0x00,0xFF,0xBD,0x31,0x00,0xFF,0xC6,0x73,0x52,0xFF,0x6B,0x31,0x18,0xFF,0xC6,0x6B,0x42,0xFF,0xCE,0x4A,0x00,0xFF,0xA5,0x63,0x39,0xFF,
    0x5A,0x31,0x18,0xFF,0x2A,0x10,0x00,0xFF,0x15,0x08,0x00,0xFF,0x3A,0x18,0x00,0xFF,0x08,0x00,0x00,0xFF,0x29,0x00,0x00,0xFF,0x4A,0x00,0x00,0xFF,0x9D,0x00,0x00,0xFF,
    0xDC,0x00,0x00,0xFF,0xDE,0x00,0x00,0xFF,0xFB,0x00,0x00,0xFF,0x9C,0x73,0x52,0xFF,0x94,0x6B,0x4A,0xFF,0x73,0x4A,0x29,0xFF,0x52,0x31,0x18,0xFF,0x8C,0x4A,0x18,0xFF,
    0x88,0x44,0x11,0xFF,0x4A,0x21,0x00,0xFF,0x21,0x18,0x10,0xFF,0xD6,0x94,0x5A,0xFF,0xC6,0x6B,0x21,0xFF,0xEF,0x6B,0x00,0xFF,0xFF,0x77,0x00,0xFF,0xA5,0x94,0x84,0xFF,
    0x42,0x31,0x21,0xFF,0x18,0x10,0x08,0xFF,0x29,0x18,0x08,0xFF,0x21,0x10,0x00,0xFF,0x39,0x29,0x18,0xFF,0x8C,0x63,0x39,0xFF,0x42,0x29,0x10,0xFF,0x6B,0x42,0x18,0xFF,
    0x7B,0x4A,0x18,0xFF,0x94,0x4A,0x00,0xFF,0x8C,0x84,0x7B,0xFF,0x6B,0x63,0x5A,0xFF,0x4A,0x42,0x39,0xFF,0x29,0x21,0x18,0xFF,0x46,0x39,0x29,0xFF,0xB5,0xA5,0x94,0xFF,
    0x7B,0x6B,0x5A,0xFF,0xCE,0xB1,0x94,0xFF,0xA5,0x8C,0x73,0xFF,0x8C,0x73,0x5A,0xFF,0xB5,0x94,0x73,0xFF,0xD6,0xA5,0x73,0xFF,0xEF,0xA5,0x4A,0xFF,0xEF,0xC6,0x8C,0xFF,
    0x7B,0x63,0x42,0xFF,0x6B,0x56,0x39,0xFF,0xBD,0x94,0x5A,0xFF,0x63,0x39,0x00,0xFF,0xD6,0xC6,0xAD,0xFF,0x52,0x42,0x29,0xFF,0x94,0x63,0x18,0xFF,0xEF,0xD6,0xAD,0xFF,
    0xA5,0x8C,0x63,0xFF,0x63,0x5A,0x4A,0xFF,0xBD,0xA5,0x7B,0xFF,0x5A,0x42,0x18,0xFF,0xBD,0x8C,0x31,0xFF,0x35,0x31,0x29,0xFF,0x94,0x84,0x63,0xFF,0x7B,0x6B,0x4A,0xFF,
    0xA5,0x8C,0x5A,0xFF,0x5A,0x4A,0x29,0xFF,0x9C,0x7B,0x39,0xFF,0x42,0x31,0x10,0xFF,0xEF,0xAD,0x21,0xFF,0x18,0x10,0x00,0xFF,0x29,0x21,0x00,0xFF,0x9C,0x6B,0x00,0xFF,
    0x94,0x84,0x5A,0xFF,0x52,0x42,0x18,0xFF,0x6B,0x5A,0x29,0xFF,0x7B,0x63,0x21,0xFF,0x9C,0x7B,0x21,0xFF,0xDE,0xA5,0x00,0xFF,0x5A,0x52,0x39,0xFF,0x31,0x29,0x10,0xFF,
    0xCE,0xBD,0x7B,0xFF,0x63,0x5A,0x39,0xFF,0x94,0x84,0x4A,0xFF,0xC6,0xA5,0x29,0xFF,0x10,0x9C,0x18,0xFF,0x42,0x8C,0x4A,0xFF,0x31,0x8C,0x42,0xFF,0x10,0x94,0x29,0xFF,
    0x08,0x18,0x10,0xFF,0x08,0x18,0x18,0xFF,0x08,0x29,0x10,0xFF,0x18,0x42,0x29,0xFF,0xA5,0xB5,0xAD,0xFF,0x6B,0x73,0x73,0xFF,0x18,0x29,0x29,0xFF,0x18,0x42,0x4A,0xFF,
    0x31,0x42,0x4A,0xFF,0x63,0xC6,0xDE,0xFF,0x44,0xDD,0xFF,0xFF,0x8C,0xD6,0xEF,0xFF,0x73,0x6B,0x39,0xFF,0xF7,0xDE,0x39,0xFF,0xF7,0xEF,0x8C,0xFF,0xF7,0xE7,0x00,0xFF,
    0x6B,0x6B,0x5A,0xFF,0x5A,0x8C,0xA5,0xFF,0x39,0xB5,0xEF,0xFF,0x4A,0x9C,0xCE,0xFF,0x31,0x84,0xB5,0xFF,0x31,0x52,0x6B,0xFF,0xDE,0xDE,0xD6,0xFF,0xBD,0xBD,0xB5,0xFF,
    0x8C,0x8C,0x84,0xFF,0xF7,0xF7,0xDE,0xFF,0x00,0x08,0x18,0xFF,0x08,0x18,0x39,0xFF,0x08,0x10,0x29,0xFF,0x08,0x18,0x00,0xFF,0x08,0x29,0x00,0xFF,0x00,0x52,0xA5,0xFF,
    0x00,0x7B,0xDE,0xFF,0x10,0x29,0x4A,0xFF,0x10,0x39,0x6B,0xFF,0x10,0x52,0x8C,0xFF,0x21,0x5A,0xA5,0xFF,0x10,0x31,0x5A,0xFF,0x10,0x42,0x84,0xFF,0x31,0x52,0x84,0xFF,
    0x18,0x21,0x31,0xFF,0x4A,0x5A,0x7B,0xFF,0x52,0x6B,0xA5,0xFF,0x29,0x39,0x63,0xFF,0x10,0x4A,0xDE,0xFF,0x29,0x29,0x21,0xFF,0x4A,0x4A,0x39,0xFF,0x29,0x29,0x18,0xFF,
    0x4A,0x4A,0x29,0xFF,0x7B,0x7B,0x42,0xFF,0x9C,0x9C,0x4A,0xFF,0x5A,0x5A,0x29,0xFF,0x42,0x42,0x14,0xFF,0x39,0x39,0x00,0xFF,0x59,0x59,0x00,0xFF,0xCA,0x35,0x2C,0xFF,
    0x6B,0x73,0x21,0xFF,0x29,0x31,0x00,0xFF,0x31,0x39,0x10,0xFF,0x31,0x39,0x18,0xFF,0x42,0x4A,0x00,0xFF,0x52,0x63,0x18,0xFF,0x5A,0x73,0x29,0xFF,0x31,0x4A,0x18,0xFF,
    0x18,0x21,0x00,0xFF,0x18,0x31,0x00,0xFF,0x18,0x39,0x10,0xFF,0x63,0x84,0x4A,0xFF,0x6B,0xBD,0x4A,0xFF,0x63,0xB5,0x4A,0xFF,0x63,0xBD,0x4A,0xFF,0x5A,0x9C,0x4A,0xFF,
    0x4A,0x8C,0x39,0xFF,0x63,0xC6,0x4A,0xFF,0x63,0xD6,0x4A,0xFF,0x52,0x84,0x4A,0xFF,0x31,0x73,0x29,0xFF,0x63,0xC6,0x5A,0xFF,0x52,0xBD,0x4A,0xFF,0x10,0xFF,0x00,0xFF,
    0x18,0x29,0x18,0xFF,0x4A,0x88,0x4A,0xFF,0x4A,0xE7,0x4A,0xFF,0x00,0x5A,0x00,0xFF,0x00,0x88,0x00,0xFF,0x00,0x94,0x00,0xFF,0x00,0xDE,0x00,0xFF,0x00,0xEE,0x00,0xFF,
    0x00,0xFB,0x00,0xFF,0x4A,0x5A,0x94,0xFF,0x63,0x73,0xB5,0xFF,0x7B,0x8C,0xD6,0xFF,0x6B,0x7B,0xD6,0xFF,0x77,0x88,0xFF,0xFF,0xC6,0xC6,0xCE,0xFF,0x94,0x94,0x9C,0xFF,
    0x9C,0x94,0xC6,0xFF,0x31,0x31,0x39,0xFF,0x29,0x18,0x84,0xFF,0x18,0x00,0x84,0xFF,0x4A,0x42,0x52,0xFF,0x52,0x42,0x7B,0xFF,0x63,0x5A,0x73,0xFF,0xCE,0xB5,0xF7,0xFF,
    0x8C,0x7B,0x9C,0xFF,0x77,0x22,0xCC,0xFF,0xDD,0xAA,0xFF,0xFF,0xF0,0xB4,0x2A,0xFF,0xDF,0x00,0x9F,0xFF,0xE3,0x17,0xB3,0xFF,0xFF,0xFB,0xF0,0xFF,0xA0,0xA0,0xA4,0xFF,
    0x80,0x80,0x80,0xFF,0xFF,0x00,0x00,0xFF,0x00,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
];
